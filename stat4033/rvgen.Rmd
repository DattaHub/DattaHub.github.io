---
title: "Random Variable Generation using Quantile Transformation"
author: "Jyotishka Datta"
date: "September 10, 2017"
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Inverse CDF Transformation

- $X$ random variable, PDF of $X$ is $p(x)$: $X \sim p(x)$.
- Cumulative density function CDF: $P(x) = \int_{-\infty}^{x} p(s) ds$
- IF $P$ is invertible, $Y = P^{-1}(U)$ will have the same distribution as $X$.
- This is called Inverse CDF/ Quantile/ Probability-Integral transformation. 

## First Example: 

- PDF of a logistic random variable. 
$$
p(x \mid \lambda) = \frac{\lambda e^{-\lambda x}}{\{1+e^{-\lambda x} \}^2}
$$
- Hence the CDF can be written as: 
$$
P(x \mid \lambda) = \frac{1}{\{1+e^{-\lambda x} \}} 
$$
- How do we generate samples from logistic? 
- Generate $U \sim U[0,1]$, and apply $P^{-1}(U)$ as above. 

## First Example Continued 

```{r, echo = TRUE,message = FALSE, warning = FALSE}
set.seed(123)
logistic_rvgen <- function(lamb,n=1){
    # Recall the signature for runif(n,high,low)
    u=runif(n)
    x=-log((1/u)-1)/lamb
    return(x)
}
```

## Visualize the samples

- Let us generate 10000 random variables from the logistic distribution

```{r, echo = TRUE, fig.height = 4}
lamb=0.1
n=10000
x=logistic_rvgen(lamb, n)
hist(x)
lines(density(x))
```

## Verify that we are correct 

- We can verify that we are correct by drawing the density along with the histogram. 

```{r, echo = TRUE, fig.height=4}
y=seq(-50,50,0.5)
fy=lamb*exp(-lamb*y)/((1.0+exp(-lamb*y))^2)
hist(x, freq  = F)
lines(y,fy, col = "red")
```

## Second Example - Exponential

```{r, echo = TRUE, fig.height=4}
n = 1e3
lambda = 2
U = runif(n)
X = - 1/lambda*log(U)
hist(X, breaks = 30, freq=F)
```

## Verify that we are correct 

- We can verify that we are correct by drawing the density along with the histogram. 

```{r, echo = TRUE, fig.height=4}
Y=seq(0,50,0.5)
fy=lambda*exp(-lambda*Y)
hist(X, breaks = 30, freq  = F)
lines(Y,fy, col = "red")
```

## Box-Mueller

- Let's do the Box-Mueller transformation 
- We generate two normal random variable $X_1$ and $X_2$ by: 
$$
U_1, U_2 \sim Unif[0,1] \\
X_1 = \sqrt{-2 \log(U_1)}cos(2 \pi U_2)\\ 
X_2 = \sqrt{-2 \log(U_1)}sin(2 \pi U_2)
$$

## In R 

```{r, echo = TRUE}
u1 = runif(n)
u2 = runif(n)
x1 = sqrt(-2*log(u1))*cos(2*pi*u2)
x2 = sqrt(-2*log(u1))*sin(2*pi*u2)
x = c(x1,x2)
```

## Plotting 

```{r, echo = TRUE}
hist(x,breaks = 30, freq = F)
curve(dnorm,add=T)
```
- Do you know another test for normality?

## QQ plots 

```{r, echo = TRUE}
qqnorm(x)
qqline(x)
```

## Lab Exercise 

- Write a sampler to generate samples from the following density using the inverse transform.

$$
p(x) = \frac{\alpha \beta^{\alpha}}{x^{\alpha + 1}} \text{for } x \ge \beta
$$


## Steps 
-  Take $\alpha = 5$, $\beta = 2$. 
-  First calculate the CDF $P(x)$
-  Then calculate the inverse $P^{-1}(x)$. 
-  Generate $U \sim \text{Unif}[0,1]$, apply $P^{-1}(U)$.

## Solution 

```{r, echo = TRUE}
Finv <- function(u){
    x = B/((1-u)**(1/a))
    return(x)
}

B = 2.0
a = 5.0
n = 10000
u = runif(n)
x = Finv(u)
```

## Plotting the solution 

```{r, echo = T, fig.height=4}
y = seq(B,20,0.1)
fy = a*(B^a)/(y^(a+1))
hist(x,breaks=100,freq=F)
lines(y,fy)
legend("topright",c("density","histogram"))
```

## Generating from the Uniform disk 

- We want to generate samples from the Uniform disk in $\mathbb{R}^2$.
$$
p(x,y) = 1/\pi \text{ if } x^2 + y^2 \le 1 
$$ 

- Exercise! 

## What does not work 

```{r, echo = TRUE, fig.align= 'center' ,fig.height = 5, fig.width= 5}
R = runif(1e4,0,1)
theta = 2*pi*runif(1e4,0,1)
X = R*cos(theta);Y = R*sin(theta)
plot(X,Y)
```
- Concentrated in the center!

## What works 
- Exercise: Why does this work? Hint = Jacobian.
```{r, echo = TRUE, fig.align= 'center' ,fig.height = 5, fig.width= 5}
X = sqrt(R)*cos(theta);Y = sqrt(R)*sin(theta)
plot(X,Y)
```

## Accept-Reject {.smaller}
 - Draw from unit cube in $\mathbb{R}^2$ and accept samples that fall inside the disc. 
 - Inefficient for higher dimensions.

```{r, echo = TRUE}
arfunction <- function(n){
  rvx = rep(0,n)
  rvy = rep(0,n)
  a = 0
  for (i in 1:n){
    x = runif(1,min = -1,max = 1)
    y = runif(1,min = -1, max = 1)
    if (x^2 + y^2 <= 1){
      rvx[i] = x
      rvy[i] = y 
      a = a + 1
    }
  }
  cat("Efficiency is ", a/n)  
  plot(rvx,rvy)
  title("Uniform on a disc")
}
```

## Disc point picking 

```{r, echo = TRUE, fig.align= 'center' ,fig.height = 5 , fig.width= 5}
n = 5000
arfunction(n)
```

 


